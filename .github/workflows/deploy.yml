name: Deploy via Terraform + Docker Hub + Compose

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      action:
        description: "Choose pipeline action"
        required: true
        default: deploy
        type: choice
        options:
          - deploy
          - destroy

env:
  TERRAFORM_DIR: infra/terraform
  SSH_USER: root
  APP_DIR: /opt/simple-app
  BACKEND_IMAGE: ivar26/simple-terraform-back
  FRONTEND_IMAGE: ivar26/simple-terraform-front
  IMAGE_TAG: ${{ github.sha }}

jobs:
  build_and_push:
    name: Build and Push Docker Images
    if: github.event_name == 'push' || github.event.inputs.action == 'deploy'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3

      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push backend image
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ env.IMAGE_TAG }}
            ${{ env.BACKEND_IMAGE }}:latest

      - name: Build and push frontend image
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.FRONTEND_IMAGE }}:${{ env.IMAGE_TAG }}
            ${{ env.FRONTEND_IMAGE }}:latest

  provision:
    name: Provision Server
    if: github.event_name == 'push' || github.event.inputs.action == 'deploy'
    runs-on: ubuntu-latest
    needs: build_and_push
    outputs:
      server_ip: ${{ steps.read_ip.outputs.server_ip }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        working-directory: ${{ env.TERRAFORM_DIR }}
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
        run: terraform init -input=false

      - name: Terraform Apply
        working-directory: ${{ env.TERRAFORM_DIR }}
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
        run: terraform apply -auto-approve -input=false

      - name: Read Server IP
        id: read_ip
        working-directory: ${{ env.TERRAFORM_DIR }}
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
        run: echo "server_ip=$(terraform output -raw server_ip)" >> "$GITHUB_OUTPUT"

  deploy:
    name: Deploy Containers
    if: github.event_name == 'push' || github.event.inputs.action == 'deploy'
    runs-on: ubuntu-latest
    needs: provision
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare SSH key
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_deploy
          chmod 600 ~/.ssh/id_deploy

      - name: Wait for server and install Docker
        env:
          SERVER_IP: ${{ needs.provision.outputs.server_ip }}
        run: |
          set -euo pipefail
          SSH_CMD="ssh -i ~/.ssh/id_deploy -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${SSH_USER}@${SERVER_IP}"

          for i in $(seq 1 30); do
            if $SSH_CMD "echo ready" >/dev/null 2>&1; then
              break
            fi
            if [ "$i" -eq 30 ]; then
              echo "SSH is not available"
              exit 1
            fi
            sleep 10
          done

          $SSH_CMD "bash -s" <<'REMOTE'
          set -euo pipefail
          export DEBIAN_FRONTEND=noninteractive

          if ! command -v docker >/dev/null 2>&1; then
            apt-get update
            apt-get install -y ca-certificates curl gnupg lsb-release
            install -m 0755 -d /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            chmod a+r /etc/apt/keyrings/docker.gpg
            . /etc/os-release
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu ${VERSION_CODENAME} stable" > /etc/apt/sources.list.d/docker.list
            apt-get update
            apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
          fi

          mkdir -p /opt/simple-app
          REMOTE

      - name: Upload compose file
        env:
          SERVER_IP: ${{ needs.provision.outputs.server_ip }}
        run: |
          set -euo pipefail
          scp -i ~/.ssh/id_deploy -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            docker-compose.prod.yml \
            "${SSH_USER}@${SERVER_IP}:${APP_DIR}/docker-compose.prod.yml"

      - name: Start containers
        env:
          SERVER_IP: ${{ needs.provision.outputs.server_ip }}
        run: |
          set -euo pipefail
          SSH_CMD="ssh -i ~/.ssh/id_deploy -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${SSH_USER}@${SERVER_IP}"

          if [ -n "${{ secrets.DOCKERHUB_USERNAME }}" ] && [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            $SSH_CMD "echo '${{ secrets.DOCKERHUB_TOKEN }}' | docker login -u '${{ secrets.DOCKERHUB_USERNAME }}' --password-stdin"
          fi

          $SSH_CMD "cd ${APP_DIR} && BACKEND_IMAGE='${BACKEND_IMAGE}' FRONTEND_IMAGE='${FRONTEND_IMAGE}' IMAGE_TAG='${IMAGE_TAG}' docker compose -f docker-compose.prod.yml pull"
          $SSH_CMD "cd ${APP_DIR} && BACKEND_IMAGE='${BACKEND_IMAGE}' FRONTEND_IMAGE='${FRONTEND_IMAGE}' IMAGE_TAG='${IMAGE_TAG}' docker compose -f docker-compose.prod.yml up -d --remove-orphans"
          $SSH_CMD "docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'"

          echo "Frontend: http://${SERVER_IP}:8080"
          echo "Backend:  http://${SERVER_IP}:5000/api/health"

  destroy:
    name: Destroy Infrastructure
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        working-directory: ${{ env.TERRAFORM_DIR }}
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
        run: terraform init -input=false

      - name: Terraform Destroy
        working-directory: ${{ env.TERRAFORM_DIR }}
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
        run: terraform destroy -auto-approve -input=false
